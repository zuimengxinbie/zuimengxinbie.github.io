---
title: 日常记录
date: 2020-03-25 00:00:00
sidebar: auto
sticky: false
permalink: /pages/skill-others200325/
categories:
  - 技术
tags:
  - skill-others
---

<p align="center">
  <img width="500" src="https://p17.qhimg.com/dmfd/2560_1440_/t01f56549810c240423.jpg"/>
</p>

> 待完善，感谢指教 🌹🌹🌹
>
> <!-- more -->

## Use

### 课外学习

- 小程序跨平台

- vue seo 解决方案

  https://blog.csdn.net/chy555chy/article/details/113814023

### 抖音日常记录

- 网址

  e.douyin.com (免费)

  https://www.doudada.com/search?v=zzz (免费)

  http://dy.myleguan.com/#/ (vip)

#### 日常記錄

1. ##### 微信小程序 - 富文本图片宽度自适应（正则）

   https://juejin.im/post/5c3d97aef265da611e4de22b

   ```javascript
   /**
   
   - 处理富文本里的图片宽度自适应
   - 1.去掉img标签里的style、width、height属性
   - 2.img标签添加style属性：max-width:100%;height:auto
   - 3.修改所有style里的width属性为max-width:100%
   - 4.去掉<br/>标签
   - @param html
   - @returns {void|string|*}
     */
   function formatRichText(html) {
     let newContent = html.replace(/<img[^>]*>/gi, function (match, capture) {
       match = match
         .replace(/style="[^"]+"/gi, '')
         .replace(/style='[^']+'/gi, '');
       match = match
         .replace(/width="[^"]+"/gi, '')
         .replace(/width='[^']+'/gi, '');
       match = match
         .replace(/height="[^"]+"/gi, '')
         .replace(/height='[^']+'/gi, '');
       return match;
     });
     newContent = newContent.replace(
       /style="[^"]+"/gi,
       function (match, capture) {
         match = match
           .replace(/width:[^;]+;/gi, 'max-width:100%;')
           .replace(/width:[^;]+;/gi, 'max-width:100%;');
         return match;
       }
     );
     newContent = newContent.replace(/<br[^>]*\/>/gi, '');
     newContent = newContent.replace(
       /\<img/gi,
       '<img style="max-width:100%;height:auto;display:block;margin-top:0;margin-bottom:0;"'
     );
     return newContent;
   }

   module.exports = {
     formatRichText,
   };
   ```

2. 字符串转数字，数字转字符串

   `parseInt`方法用于将字符串转为整数。如果字符串头部有空格，空格会被自动去除

   `parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分

   (注意)如果字符串以`0x`或`0X`开头，`parseInt`会将其按照十六进制数解析

   ```java
   parseInt('123') // 123

   ```

3. es6 解构赋值

   ```javascript
   let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
   es6默认使用 === ， 只有数组元素严格等于undefined,默认值才会生效；
   否则，不生效，
   let [x = 1] = [null];
   x // null
   null 不严格等于undefinde，默认值不生效
   ```

![2019-05-31_093305](D:\学习案例\日记\2019-05-31_093305.png)

![2019-05-31_093320](D:\学习案例\日记\2019-05-31_093320.png)

4. 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。

   ```javascript
   let [x = 1, y = x] = [];     // x=1; y=1
   let [x = 1, y = x] = [2];    // x=2; y=2    x先等于2，然后在赋值给y
   let [x = 1, y = x] = [1, 2]; // x=1; y=2    x先等于1，让后被1覆盖，然后y=1，让2将y覆盖
   let [x = y, y = 1] = [];     // ReferenceError: y is not defined

   上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。
   ```

5. 对象的结构赋值，可以把现有对象的方法，赋值到某个变量上

   ```javascript
   let { log, sin, cos } = Math;   因为Math本身是一个对象，可以进行输出查看，let前面的变量名在Math中都可以找到，对应的赋值过去

   // 例二
   const { log } = console;    console是一个对象，赋值查看，其中的log函数给拿出来
   log('hello') // hello
   ```

6. 变量名与属性值不同

   ```javascript
   let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
   baz; // "aaa"
   ```

7. 对象的解构赋值是下面形式的简写（**赋值的是后者，而不是前者。**）

   > ```javascript
   > let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
   > 对象的解构赋值内部机制，先找到同名属性，然后赋给对应的变量。真正被赋值的是后者，而不是前者。
   > // 前面那个foo 是匹配的模式
   > ```

![2019-05-31_111940](D:\学习案例\日记\2019-05-31_111940.png)

 可以多次被赋值

8. 默认值

   ```javascript
   var {x: y = 3} = {x: 5};
   y // 5
   第一步：先将x赋值给y，y=3,然后被5覆盖掉
   ```

![2019-05-31_134921](D:\学习案例\日记\2019-05-31_134921.png)

9. 只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

10. 结构赋值的规则：只要等号右边的值**不是对象或者数组，就先将其转为对象**，由于 nudefined 和 null 无法转为对象，所有对它们进行结构赋值，会报错

11. > **函数参数的解构赋值**
    >
    > ```javascript
    > function move({ x, y } = { x: 0, y: 0 }) {
    >   return [x, y];
    > }
    > /// 解析的时候不要看等号“=”后方的赋值
    > move({ x: 3, y: 8 }); // [3, 8]
    > move({ x: 3 }); // [3, undefined]
    > move({}); // [undefined, undefined]
    > move(); // [0, 0]
    > ```

12. jquery 获取 data 上的值（data-type）

    ```
    const actnum = $('.classify-box .leixingwk').find(".actived").data('type')-1
    ```

13. `Number.isInteger()`用来判断一个数值是否为整数。

    ```javascript
    Number.isInteger(25); // true
    Number.isInteger(25.1); // false
    ```

14. 微信小程序转百度小程序

    https://blog.csdn.net/fengye002011/article/details/83211857

15. pr

    http://k.sina.com.cn/article_5518294305_148ea7d2100100acml.html?cre=tianyi&mod=pcpager_fintoutiao&loc=13&r=9&doct=0&rfunc=77&tj=none&tr=9

16. premise

    promise 是个雨布操作容器,需要在 promise 中装过异步操作进去才行

17. ```
    substring（使用）
    要和trim（）方法來结合使用
    ```

18. python 使用

19. fidder 使用帮助

    让手机与电脑同步起来

20. 在小程序中实现 Mixins 方案
    https://segmentfault.com/a/1190000019527762

21. 图片处理(图片加载失败,显示背景图

    - 第一种(背景图片处理)

    ```css
    .imgbox img {
      display: block;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: relative;
      color: #ffffff;
    }
    .imgbox .morenInfo:after {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: url('../../../common/img/moren.png') no-repeat center;
      background-size: 100% 100%;
      position: absolute;
      content: '';
      display: block;
      top: 0;
      left: 0;
    }
    ```

    - 第二种(js 处理)

    ```
    <img onerror="javascript:this.src='1.jpg'" src="http://staticqn.qizuang.com/logoadv/20170809/Fs5rcQAOzftkmco9vtTJtA4Vxzlo" alt="干将壹号装饰">
    ```

22. 运营人员必知术语

    http://www.360doc26.net/wxarticlenew/724572498.html

23. input,按钮:使用 disabled 属性来禁止事件

    div 元素 使用 在 div 上加 css 属性：pointer-events:none 来禁止事件

24. 根据 id 取出数组中的对象

    ```javascript
    var arr = [
      {
        id: 1,
        name: 'a',
      },
      {
        id: 2,
        name: 'b',
      },
    ];
    var obj = arr.find(function (x) {
      return x.id === 1;
    });
    console.log(obj);
    ```

25. 回到顶部

    ```javascript
      goTop: function (e) {
             swan.pageScrollTo({
                    scrollTop: 0,//节点的上边界坐标
                    duration: 1000 //滑动到目标点的时间
                });
      }
    百度小程序借助 scoll-view 只能回滚一次,具体原因排查
    ```

26. 添加新的响应式属性应该这样做：

    ```javascript
    data: {
      userprofile: {
        name: 'xiaoming';
      }
    }
    this.userProfile = Object.assign({}, this.userProfile, {
      age: 27,
      favoriteColor: 'Vue Green',
    });
    ```

27. 实用工具库

    Lodash

    https://www.lodashjs.com/

28. vue 不同场景通讯

    https://segmentfault.com/a/1190000019208626?utm_source=tag-newest

29. element 下不同规则匹配

    - 输入必须为数字

      ```javascript
      let verCode = (rule, value, callback) => {
        let reg = /^[0-9]+$/g;
        if (!value) {
          callback('版本号不能为空');
        } else if (parseInt(value) <= 1) {
          callback('请输入大于1的数字');
        } else if (!reg.test(value)) {
          callback('版本号输入有误');
        } else {
          callback();
        }
      };
      ```

    - 链接网址

      ```javascript
      let appCheck = (rule, value, callback) => {
        const reg = /^[^\u4e00-\u9fa5]+$/;
        if (!reg.test(value)) {
          callback('APP下载链接输入有误');
        } else if (!value) {
          callback('APP下载链接不能为空');
        } else {
          callback();
        }
      };
      ```

    - ```
      密码
      ```

      ```javascript
      const validPsw = (rule, value, callback) => {
        if (!value) {
          callback(new Error('登录密码不能为空，请输入'));
        } else if (value.length < 6 || value.length > 16) {
          callback(
            new Error('密码输入错误，6-16位数字、英文字母，特殊符号组成的密码')
          );
        } else if (!checkPureSymbal(value)) {
          callback(
            new Error('密码输入错误，6-16位数字、英文字母，特殊符号组成的密码')
          );
        } else {
          callback();
        }
      };
      ```

    - 正整数

      ```
      { required: true, message: '扣款金额不能为空' },
      { type: 'number',
        message: '请输入正整数',
        trigger: 'blur',
        transform(value) {
          if (!/^[1-9]\d*$/.test(value)) {
            return true
          }
        }
      }
      ```

30. 小程序对于内容展开收起

31. 回到顶部(百度小程序)

    注意绑定的属性写法

    - 设置竖向滚动条位置。要动态设置滚动条位置，用法`scroll-top="{= scrollTop =}"`

32. input 处理
    input 默认有这玩意,反而会影响使用
    input 中增加 attr autocomplete="off"
    <input  autocomplete="off" />

33. Html 页面纯数字或者纯字母不能换行的解决办法

    ```
    word-break:break-all;
    word-wrap:break-word;
    ```

34. ajax 和 axios、fetch 的区别

    https://www.jianshu.com/p/8bc48f8fde75

35. 代码改完了,发现分支错了

    ###### 前提是尚未将修改提交到错误的分支

    ```javascript
    > git stash
    > git checkout targetbranch
    > git stash pop
    > git add .
    > git commit -m xxx
    ```

    第一步，将修改的代码暂存到 stash

    第二步，切换到正确的分支

    第三步，从 stash 中取出暂存的代码修改。

    至此，对代码的改动，就由错误的分支移动到了正确的分支。

36. websocket 设置心跳连接

    https://www.cnblogs.com/buxiugangzi/p/11379883.html

    https://www.jianshu.com/p/5297732db7f2

    https://www.jianshu.com/p/09b91b9a778f

    在 socket.readyState == 3(已经关闭了与服务器的连接)才真正的发起连接，
    在 socket.readyState == 1(与服务器已经建立连接)或重试次数超了设定值就终止重试，但要注意在终止浏览器页面及网络恢复时重刷页面
    在 socket.readyState == 0(正尝试与服务器建立连接)或 socket.readyState == 2(正在关闭与服务器的连接)时仅仅重试，而不发起连接

37. 数据长链接

    https://www.51csdn.cn/article/377.html

    https://www.cnblogs.com/qisi007/p/10213886.html

38. 微信小程序图片上传删除和预览

    https://blog.csdn.net/anLazyAnt/article/details/77374905

39. 图片/视频上传七牛

40. 获取 url

    https://www.cnblogs.com/wang98/p/7688186.html

41. css 加强

    https://www.zhangxinxu.com/wordpress/category/css/page/30/

42. 学习网址

    https://github.com/jnoodle/f2e-collect#s2

    https://github.com/JacksonTian/fks

43. 极验证

44. vue 后台分页写法

    ```
    handleSearch() {
        this.currentPage = 1
        this.getList()
    },
    // 分页处理
    handleSizeChange() {
        this.currentPage = 1
        this.getList()
    },
    handleCurrentChange(val) {
        this.currentPage = val
        this.getList()
    },
    getList() {
      const queryObj = this.handleArguments()
      this.loading = true
      list(queryObj).then(res => {
        if (parseInt(res.error_code) === 0) {
          if (res.data.list.length <= 0 && this.currentPage > 1) {
            this.currentPage--
            this.getList()
          } else {
            this.loading = false
            this.tableData = []
            this.totals = res.data.page.total_number
            this.pageSize = res.data.page.page_size
            res.data.list.forEach((item, index) => {
              this.tableData.push(item)
            })
          }
        }
      })
    }
    ```

45. 正则验证方法

    ```javascript
    const validateRatio = (rule, value, callback) => {
      if (parseFloat(value) === 0) {
        callback(new Error('请选择单倍/几倍'));
      } else {
        callback();
      }
    };
    const validateisNewMember = (rule, value, callback) => {
      if (parseInt(value) === 0) {
        callback(new Error('请选择新/老会员'));
      } else {
        callback();
      }
    };
    const validatePhone = (rule, value, callback) => {
      if (!value) {
        callback(new Error('请输入电话'));
      } else if (!checkPhoneNum(value)) {
        callback(new Error('请输入正确的手机号'));
      } else {
        callback();
      }
    };
    const validateInt = (rule, value, callback) => {
      const reg = /^[+]{0,1}(\d+)$/;
      if (value && !reg.test(value)) {
        callback(new Error('请输入正整数'));
      } else {
        callback();
      }
    };
    const validateSize = (rule, value, callback) => {
      if (value.length < 6) {
        callback(new Error('账号最少为6位'));
      } else {
        callback();
      }
    };
    const validateisMode = (rule, value, callback) => {
      if (parseInt(value) === 0) {
        callback(new Error('请选择合作模式'));
      } else {
        callback();
      }
    };
    const validateisDate = (rule, value, callback) => {
      if (parseInt(this.ruleForm.cooperationMode) === 2) {
        callback();
      }
      if (!value) {
        callback(new Error('请选择合同开始时间'));
      } else {
        callback();
      }
    };
    const validateisDateEnd = (rule, value, callback) => {
      if (parseInt(this.ruleForm.cooperationMode) === 2) {
        callback();
      }
      if (!value) {
        callback(new Error('请选择合同结束时间'));
      } else {
        callback();
      }
    };
    ```

46. element-ui 表单加判断条件显示必填或非必填

    ```javascript
    var validateGao = (rule, value, callback) => {
      const on = this.postForm.adv_on; //  中途拦截做判断
      if (!value || parseInt(on === 2)) {
        callback(new Error('请填写广告文案'));
      } else {
        callback();
      }
    };
    ```

47. 混入概念理解 mixin

    分发 vue 组件中的可复用功能

    总结:

    - mixin 混入-公共的逻辑功能块,可以混到组件中去,但是组件之间不影响

    https://www.jianshu.com/p/772d67305f98

48. 图片上传

    - 发送头部

      ```
      headers: { 'Content-Type': 'multipart/form-data' }
      ```

    - 创建发送的 formData 对象

      ```
      const formData = new FormData()
      formData.append('file', blobInfo.blob())
      ```

49. **学习网址**

    - https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign MDN 网址

50. 解决 vue+el-element 二级联动，选项选择后不显示的问题

    updateFun() {

    this.$forceUpdate()

    }

51. value 采用拼接方式

    :value="`${item.level}.${item.tableName}`">

52. git 切换新分支命令行

    git checkout -b feature-655

    git pull origin feature-655

53. 小程序自定义弹框

54. 携带对象传递

    传递前:JSON.stringify(item)

    传递后: JSON.parse(item)

55. vscode 学习

    https://geek-docs.com/vscode/vscode-tutorials/what-is-vscode.html

56. vue 获取验证码

57. 百度地图应用 ak

    http://lbsyun.baidu.com/apiconsole/key/update?app-id=10852372

    官方文档: https://dafrok.github.io/vue-baidu-map/#/zh/start/usage

58. User-Agent

    - 请求头中的字段
    - 告知是用户浏览器,而非爬虫
    - 模拟浏览器来去访问

59. postman 不用更换 host,内部访问

60. 防止多次点击

    https://www.cnblogs.com/shiblog/p/12119672.htm

61. eslint

    https://eslint.org/docs/rules/object-shorthand.html

62. Babel

    https://www.babeljs.cn/docs/

63. tampermonkey

    js 爬取数据工具

64. day.js(日期处理工具)

    https://day.js.org/docs/zh-CN/installation/typescript

65. element 时间限制处理

    https://blog.csdn.net/qq_33769914/article/details/83856268

    ```
      pickerOptions0: {
              disabledDate(time) {
                return time.getTime() > Date.now() - 8.64e6;//如果没有后面的-8.64e6就是不可以选择今天的
              }
            },
    ```

66. 全局路由守卫使用

    ```vue
    router.beforeEach((to, from, next) => { const telSafe =
    JSON.parse(localStorage.getItem('telSafe')) if (telSafe === ''){ if (to.path
    === '/alter'){ next() }else { next({ name: 'Alter', params: { safe: 1, } })
    } }else { next() } })
    ```

67. script 中属性 defer 与 async

    defer

    - 如果你的脚本代码依赖于页面中的 DOM 元素(文档是否解析完毕,)或者被其他脚本文件依赖

      babel(polyfill.js)

    async

    - 脚本不关心页面中的 DOM 元素,异步的进行,并且不会产生其他脚本需要的数据

      百度统计

68. 创建发单页面

    https://qizuang.coding.net/p/qz_mobile/d/qz_mobile/git/merges/create/master...feature-918

69. 三方平台

    <http://demo.open.renren.io/renren-fast/#/login>

70. 插件安装

    <https://www.bootcdn.cn/>

71. 输入框过滤数字与特殊字符

    ```
      <el-input v-model="ruleForm.nick_name"  oninput="value=value.replace(/[^\a-zA-Z\u4E00-\u9FA5]/g,'')"  maxlength="20" placeholder="请输入姓名"></el-input>
    ```

72. element v-if 条件渲染问题

    问题: element 条件判断渲染哪一个模板,结果其中有一个模板的 options 属性渲染不上去

    解决方案: 在每个渲染的标签上添加 key 值,让 vue 独立渲染

73. 输入为数字,自定义指令

    <https://www.jb51.net/article/169052.htm>

74. 语雀(记笔记工具)

    <https://www.yuque.com/dashboard>

75. jquery 数据处理

    ```
    (5) [{…}, {…}, {…}, {…}, {…}]
    0: {name: "order_id", value: "2020061031956034"}
    1: {name: "track_status", value: "2"}
    2: {name: "track_type", value: "99"}
    3: {name: "track_info", value: ""}
    4: {name: "next_time", value: ""}


    var need = {}
    $.each(data, function(i,v){
    need[v.name] = v.value
    })
    
    console.log(need.XXXX)
    ```

76. APP 和 H5 联调

    <http://wiki.qizuang.net/pages/viewpage.action?pageId=1540340>

77. 解决 type=number 时，限制长度失效

    ```javascript
    <input class="new-mianji" type="number" oninput="if(value.length>5)value=value.slice(0,5)">
    ```

78. /deep/ 深度选择器

79. js 截取某个字段后面的字符串

    ```
    var str = 'p2p-dafei';
     console.log(str.split("p2p-")[1]);
    //截取p2p-后面的所有参数
    ```

80. map 输出数组

    ```
    const xImg = this.imgs.map((item) => {
      // item.img_id = item.id
      // item.checked = item.check === true ? 1 : 0
      // return item
      return {
        img_id: item.id,
        checked: item.check === true ? 1 : 0
      }
    })
    ```

81. 从列表页跳转到详情页

    https://blog.csdn.net/erduoduo1989/article/details/117082528

    https://www.cnblogs.com/sysuhanyf/p/7454530.html

82. flex 流动布局中单个子元素位置如何自定义

    三个元素最右边的一个元素只需要设置 margin-left: auto, 即可实现第三个元素浮动到最右边

83. vue 补充

    v-once 执行一次性插值，当数据改变时，插值处的内容不会更新。

    v-bind 用来绑定属性

    v-on 用来绑定事件

    ```
    <a v-bind:[attrubuteName]="url">............</a>

    当Vue实例中有一个data的property attributeName ，值为“href”、
    简写： ”：“

    <a v-on:[eventName]="dosomething">.......</a>
    当eventName的值为“focus”时， 相当于 v-on:focus ="dosomeThing"
    简写： “@”
    ```

    v-bind:class 指令也可以与普通的 class 属性共存

    v-bind:class 的属性可以为一个对象

84. class

    v-bind:class, 传给一个对象，已动态的切换 class

    v-bind:class, 传给一个数组，以应用一个 class 列表

    v-bind:style, 传一个 javascript 对象

    .lazy

    在默认情况下，v-model 在每次 innput 事件后将输入框的值与数据进行同步，你可以添加 lazy 修饰符，，从而在 change 事件后进行同步

    .number

    如果想自动将用户的输入值转为数据类型，可以给 v-model 添加 number 修饰符

    .trim

    如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符

85. 字符串和变量拼接

    let s3 = "a" + b + "c"

    let s3= `a${b}c`

86. async/await

    异步函数避免回调地狱，让代码看起来简单

    async 关键字告诉 javascript 要以不同的方式处理这个函数，在遇到函数中的 await 关键字时，编辑器会暂停，

    **假定 await 之后的表达式会返回一个 promise，知道 promise 完成或者拒绝**

87. async/await 函数的错误处理

    使用 async/await 时，有多钟方法处理错误

    选项 1——在函数中使用 try catch

    ![ECMAScript 2016/2017/2018新特性详解](http://p9.pstatp.com/large/pgc-image/1539914551584e211d398ca)

    选项 2——捕获每个 await 表达式

    由于每个 await 表达式都返回一个 Promise，因此可以像下面这样捕获每行的错误。

    ![ECMAScript 2016/2017/2018新特性详解](http://p3.pstatp.com/large/pgc-image/15399145516434253284afa)

    选项 3——捕获整个 async-await 函数

    ![ECMAScript 2016/2017/2018新特性详解](http://p1.pstatp.com/large/pgc-image/1539914551595d569591922)

88. count（）和 list（）有先后顺序

    ```
    let c = await count()
    let l = await list()

    两个异步请求无关联和先后顺序
    let res = await Promise.all([count(), list()])
    return res
    将count()和list() 使用promise.all()同时执行，这里count（）和list（）可以看作是“并行执行”，所耗时间将是两个异步操作中耗时最长的耗时
    ```

89. 与 Generator 的关系

    Generator 将异步操作表示的很简洁，流程管理却不方便（何时执行第一阶段，何时执行第二阶段）。一种自动执行 Generator 函数方法。

90. async 与 await

    async 用于申明一个异步函数，await 用于等待一个异步方法执行完成

    await 只能出现在 async 函数中

91. babel

    下一代 javaScripty 语法的解释器

    - 语法解释

    - 通过 polyfil 方式在目标环境中添加缺失的特性（通过 @babel/polyfill 模块）

    - 源码转换（codemods）

      .babelrc 配置文件

      - 预设（presets）

        告诉 Babel 要转换的源码使用了哪些新的语法特性，presets 是一组 plugins 的集合

        某一类 plugin 的集合，包含了某一类插件的所有功能

      - 插件（plugins）

        将某一种需要转换的代码，转为浏览器可以执行代码

    - 执行顺序

      - 执行 plugins 中所有的插件
      - 插件按照顺序依赖编译
      - 执行完成，在执行 presets 预设
      - 预设，按照倒序的顺序执行
      - 完成编译

    - 配置详解

      - terget

        描述项目配置的 支持/定位 的环境

92. vue 各种 import 引入

    - 引入第三方插件

      import echarts from 'echarts'

    - 引入单个方法

      import {axiosfetch} from './util';

      export function axiosfetch(options) {

      ......

      }

    - 引入组的方法

      import **\* as tools** from './libs/tools'

      tools.js 中有多个 export 方法，把 tools 里所有 export 的方法导入

      使用

      - 全局

        Vue.prototype.$tools = tools

        直接使用 this.$tools.method 调用

      - 局部

        tools.method

    - export 和 export default 区别

      - export

        导入

        import { axiosfetch } from './util';

        需要加花括号，可以导入一个，也可以导入多个

      - export default

        import axiosfetch from './util';

        不需要加花括号，只能一个个导入

    - 导入 js

      想给 Array 封一个属性，首先新建个 prototype.js 文件

      文件里

      Array.prototype.max = function(){

      return Math.max.apply({},this);

      }

      import './libs/prototype'

      在 main.js 中引用，那么在所有的组件都可以用

      [].max();

93. ref/$refs 的使用场景 --- vue 组件通信系列

    作用： 获取节点或组件实例

    场景：简单的获取节点或组件实例的属性或者方法，但不改变其数据。

    缺陷： 必须是模板渲染之后，不是响应式的，时不时配合$nextTick

    - 节点时，可以通过`this.$refs.p`得到节点的属性或者方法，如`<p ref="p">hello</p>`
    - 组件时，可以通过`this.$refs.child`得到相应的组件实例，从而得到组件上面的属性和方法，如`<child-component ref="child"></child-component>`
    - v-for 语法时，可以通过`this.$refs.items`得到节点或组件实例的数组，具体的某项，需要`this.$refs.items[index]`，如`<item ref="items" v-for=".">hello</item>`

    在数据变化后要执行的某个操作，操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放进 Vue.nextTick()的回调函数中

94. 日常安装组件

    -- save 安装，保证 packjson 文件中有对应记录

95. [https://kaifa.baidu.com](https://kaifa.baidu.com/)

96. Proxy 是专门为对象设置访问代理器的，通过 Proxy 可以轻松监视到对象的读写过程。

    浏览器限制的

    promise 目的不是为了开启异步任务，而是为了解决异步代码的书写格式，尽量实现函数回调的扁平化，

97. swiper 监听滑动事件

    ```
    on: {slideChangeTransitionEnd: function(){console.log(this.realIndex)}}
    ```

98. 父子组件

    父组件调用子组件中的属性，方法

    ```xml
    this.$refs.hello.msg
    this.$refs.hello.open();
    ```

    子组件调用父组件中的方法

    ```
    子组件
     this.$emit("refreshData");

    父组件
     <div id="app">
        <HelloWorld ref="hello" @refreshData="getData"/>
      </div>
    ```

99. vue （keep-alive 缓存问题）

    https://www.jianshu.com/p/0167cc3546fe

    1 使用`keep-alive`包裹`router-view`

    ```xml
    <div id="app">
            <keep-alive>
                <router-view v-if="$route.meta.keepAlive"></router-view>
            </keep-alive>

            <!-- 这里不会被keepalive -->
            <router-view v-if="!$route.meta.keepAlive"></router-view>
    </div>
    ```

    2 路由注册,添加`meta`

    ```css
     {
          path: '/list',
          name: 'List',
          component: () => import('@/pages/list.vue'),
          meta: {
            keepAlive: true
          }
    },
    ```

    3 `list.vue`中使用`beforeRouteLeave`钩子

    ```csharp
    export default {
      beforeRouteLeave(to, from, next) {
        from.meta.keepAlive = false
        next()
      }
    }
    ```

    4 detail.vue`中使用`beforeRouteLeave`钩子

    ```
    export default {
      beforeRouteLeave(to, from, next){
        if(to.name === 'List') {
          to.meta.keepAlive = true
        }
        next()
      }
    }
    ```

100. /deep/ 和 v-deep

101. vue 骨架屏

     https://www.cnblogs.com/binmengxue/p/12486376.html

     https://blog.csdn.net/loria1/article/details/87601442

102. dependencies 与 devDependencies

     相同：

     你和别人 clone 这个库进行开发调试的时候，可以通过 npm install 一键安装这两个目录下所有的依赖，而不用一行行去找

     不同点：

     dependencies 声明的依赖，是项目运行的依赖

     devDependencies 开发时的依赖

103. vue 中的$attrs 和$ listeners

104. vue 添加响应 response 拦截器，响应登陆超时处理

     https://blog.csdn.net/mushui0633/article/details/106147341

105. 做一个全局登录弹窗，任何地方访问

     https://juejin.cn/post/6960163479512678437

106. vue 项目首次加载慢，会出现短暂白屏

     - 给个 loading 菊花挡一下
     - 考虑对于页面的组件做异步加载
     - webpack 打包优化，减小打包文件体积大小
     - vuejs 路由的懒加载策略
     - 配置 vue-cli，利用 webpack 插件完成模板预加载
     - 考虑服务器渲染首屏骨架页面，或者更复杂的服务器渲染策略 ssr，官方有文档

107. vue 打包环境配置

     https://www.cnblogs.com/jlyuan/p/13614242.html

108. vue 强制更新$forceUpdate()

     ```
     vue强制更新$forceUpdate()

     添加this.$forceUpdate();进行强制渲染，效果实现。搜索资料得出结果：因为数据层次太多，render函数没有自动更新，需手动强制刷新。

     调用强制更新方法this.$forceUpdate()会更新视图和数据，触发updated生命周期。

     我是在使用多层for循环嵌套时出现的页面没有及时刷新改变后的值的问题( 使用this.$forceUpdate()
     ```

109. vue 深拷贝

     ```
     JSON.parse(JSON.stringify(arr));
     import _ from 'lodash'
     _.cloneDeep(arr)
     ```

110. 正则匹配

     ```
     只输入整数：   oninput="value=value.replace(/[^\d]/g,'')"
     只输入整数（带小数）：   oninput="value=value.replace(/[^\d.]/g,'')"

     首位不能输入0（正整数）： oninput="value=value.replace(/\D/g, '').replace(/^0{1,}/g, '')"
     ```

111. 小程序扩展运算符使用高级 js 语法，如‘.toFixed’，‘toString()’，通过引入 wxs 模块实现

     ```
     - 新建`filter.wxs`
     var filters = {
         toFix: function (value) {
             return value.toFixed(2)
     }
     module.exports = {
         toFix: filters.toFix,
     }

     - WXML
     <wxs module="filters" src="../../utils/filters.wxs"></wxs>
     <view>{{ filters.toFix(price) }}</view>
     ```

112. 小程序引入 iconfont 字体图标

     https://blog.csdn.net/janyxh/article/details/120361834

113. $emit 传递参数

     传递一个 $event

     传递多个 arguments

114. **函数预编译四部曲**

     - 创建 AO 对象
     - 找形参和变量声明，值为 undefined
     - 将实参与形参统一
     - 函数体里找函数声明，值赋予函数体

115. **全局预编译三部曲**

     - 生成 GO 的对象
     - 找变量声明，值为 undefined
     - 找函数声明

116. Object.fromEntries

     ```
     arr = [
     	['name', '小明'],
     	['age', 19]
     ]
     objJect.fromEntries(arr)
     // 结果
     {name: '小明'， age: 19}
     ```

117. Array.from

     ```
     Array.from([1,2,3], x=>x+3)
     // 结果
     [4,5,6]
     ```

#### 算法

1. 通过 id 取出数组中对应的对象![97616b10046fe81bc977c2a5608bf2e](D:\日记\0505\97616b10046fe81bc977c2a5608bf2e.png)

   - 指定 id

     ```javascript
     let id=1;
     let obj=this.arr.find(function (obj) {
           return obj.id ==id;
         }）
     ```

   - 数组 id

     ```javascript
     let arr1 = [{},{},{},....]
     let arr2 = [1,2,3,...]
     myFilter(arr1,arr2) {
         return  arr1.filter((ele) =>
             arr2.filter((x) => x === ele.id).length > 0
         );
       }
     
          const fgList = this.fg.filter((ele)=> {
                   // eslint-disable-next-line no-unused-expressions
                   return datas.fengge.filter((x) => x === ele.id).length >0
                 })
     ```

2. 将对象转化为数组

   ```javascript
   const json = {
       1: 'a',
       2: 'b',
       3: 'c',
       4: 'd',
   }
   function jsonToArray(e){
       return Object.keys(e).map((value) => ({
           id: value,
           name: e[value]
       }));
   }
   console.log(jsonToArray(json))
   // 结果
   [
       {id: '1',name: 'a'},
       {id: '2',name: 'b'},
       {id: '3',name: 'c'},
       {id: '4',name: 'd'},
   ]
   ```

3. 数组转化对象

   ```javascript
   let arr = [
       {id: '1',name: 'a'},
       {id: '2',name: 'b'},
       {id: '3',name: 'c'},
       {id: '4',name: 'd'},
   ]
   let obj = {}
   arr.map((item)=>{
   	obj[item.name] = item.id
   })
   // 结果
   {
       a: 1,
       b: 2,
       c: 3,
       d: 4
   }
   ```

4. 判断是否为空对象，空数组

   ```javascript
   let json = [] ? {}
   JSON.stringify(json) === '[]'）
   JSON.stringify(json) === '{}'）
   console.log([] === [])  // false
   console.log({} === {})  // false
   ```

5. 数组合并

   ```
   let arr1 = [ {"order":"20201","company_id":"666496","com":"666496","isread":1,"allot_source":3,"jc":"黑鲸设计工作室","qc":"武汉黑鲸室内设计工作室"},
   {"order":"20202","company_id":"236989","com":"236989","isread":1,"allot_source":3,"jc":"武汉一家一装饰","qc":"一家一欧标装饰工程有限公司"},
   ]
   let arr2 = [
   {'comid':64132,'lf_time':'','liangfang':2,'orderid':'20201','status':0,'time':''},
   {'comid':236989,'lf_time':'','liangfang':2,'orderid':'20202','status':0,'time':''},
   {'comid':666496,'lf_time':'','liangfang':2,'orderid':'20203','status':0,'time':''}
   ]
   
   arr2.forEach((item)=>item.order = item.orderid)
   
   let list=arr1.reduce((pre,cur)=>{
     let target=pre.find(ee=>ee.order == cur.order)
     if(target){
       Object.assign(target,cur)
     }else{
       pre.push(cur)
     }
     return pre
   },arr2)
   ```

6. 自身数据合并

   ```
   function merge(data) {
       let arr = []
       data.forEach((item) => {
           arr = [...arr, ...item.children]
       })
       return arr
   }
   ```

7. json 数组去重

   ```
   this.manages = this.manages.reduce(function(item, next) {
       hash[next.id] ? '' : hash[next.id] = true && item.push(next)
       return item
   }, [])
   ```

8. 获取 json 数组中的每项值

   ```
   arr = [
       {name: 'jack', age: 12, sex: 'boby'},
       {name: 'jack', age: 12, sex: 'boby'},
       {name: 'jack', age: 12, sex: 'boby'}
   ]
   let result = arr.map(Object.values)
   let flatten = result.toString().split(',');
   console.log(flatten)
   ```

9. 判断某一类数组里面有没有这个东西,只要一个存在就返回 true

   ```
   let array=[
           {
               name:'jack',
               age:'19'
           },
           {
               name:'rose',
               age:'19'
   
           }
       ]
       var box=array.some((value,index)=>{
           return value.name=='jack'
       })
     console.log(box,"box") //true "box"
   ```

10. 计算数组中数据之和

    ```
    let sum = item.goodsSkuIdList[0].reduce(function (prev, cur) {
     return cur.goodsNum + prev
    }, 0)
    ```

11. 判断数组是否有重复值

    ```
    function isArrRepeat2(_arr){
        let len=_arr.filter((item,index)=>{
            return _arr.indexOf(item)!=index;
        }).length;
        return len>0?true:false;
    }
    ```

12. 解构赋值新用法

    ```javascript
    todos: [
        {id:'001',name:'吃饭',done:true},
        {id:'002',name:'睡觉',done:true},
        {id:'003',name:'打代码',done:false},
        {id:'004',name:'逛街',done:false}
    ],
    const {todos} = this.state
    const newTodos = todos.map((todoObj)=>{
        return {...todoObj,true}
    })
    this.setState({todos: newTodos})
    ```

13. 去除数组中 empty,null,undefined

    ```
    arr.filter((d) => d)
    ```

14. json 判断其中字段重复

    ```
      if ([...new Set(list.map(item => item.value))].length < list.length) {
        console.log('有重复')
      }
    ```

15. 相同 key 值合并

    ```
    const oldData = [
        { id: 1, value: '11' },
        { id: 1, value: '12' },
        { id: 2, value: '22' },
        { id: 2, value: '23' },
        { id: 2, value: '24' },
        { id: 3, value: '33' },
        { id: 3, value: '34' },
        { id: 4, value: '44' }
    ]
    
    const s = new Set()
    oldData.forEach(item => s.add(item.id))
    let newData = Array.from({ length: s.size }, () => [])
    oldData.forEach(item => {
        let index = [...s].indexOf(item.id)
        newData[index].push(item)
    })
    ```

16. 对数组进行分类

    array.groupBy

    ```javascript
    const people = [
      { name: 'Alice', age: 21 },
      { name: 'Max', age: 20 },
      { name: 'Jane', age: 20 }
    ];
    // 实现
    const groupedPeople = {
      20: [
        { name: 'Max', age: 20 },
        { name: 'Jane', age: 20 }
      ],
      21: [
        { name: 'Alice', age: 21 }
      ]
    }
    
    // 最优方案
    const groupedPeople = people.groupBy(({ age }) => age)
    // 支持按条件自定义分类
    const groupedPeople = people.groupBy(({ age }) => age <= 20? 'a': 'b')
    groupedPeople is:
    {
        'a': [
            { name: 'Max', age: 20 },
            { name: 'Jane', age: 20 }
        ],
        'b': [
            { name: 'Alice', age: 21 }
        ]
    }
    ```

17. 数组操作

    ```
    - 相加求和
    let sum = 0;
    let arr = [1,5,89,5]
    arr.forEach(item =>{
        sum = sum + item
    })
    
    - 数组去0或者去其他
    let arr = [4, 0, 7, 9, 0, 0, 2, 6, 0, 3, 1, 0]
    let newArr = []
    arr.forEach(item =>{
       item == 0 ? 'continue' : newArr.push(item)
    })
    
    - 数组去重
    let  arr = [1,2,123,3,5,45,1,2,5]
         arr = [...new Set(arr)]
    
    - 数组中求最大值
    let  arr = [1,5,56,6,1,1,21,45,4]
    let  max = arr[0]
    arr.forEach((item,index) => item > max ?  max = arr[index] : max)
    
    - 数组中求最小值
    let  arr = [1,5,56,6,1,1,21,45,4]
    let  min = arr[0]
    arr.forEach((item,index) => item < min ?  min = arr[index] : min)
    
    数组从小到大排序
    let  arr = [1,5,56,6,1,1,21,45,4]
    arr.sort((a,b) => a - b)
    
    数组取值（从后往前）
    let arr = ['this is the first element', 'this is the second element', 'this is the last element'];
    console.log(arr.at(0))              // logs 'this is the first element'
    console.log(arr.at(-2))             // logs 'this is the second element'
    console.log(arr.at(-1))             // logs 'this is the last element'
    ```

#### 自定义指令

<https://www.cnblogs.com/tuspring/p/12169978.html>

#### 扩展

1. 技术

   - 大前端-Vue 技术栈的 SSR 服务端渲染

   - 组件化-前端业务组件化项目

   - React 技术栈、小程序多端同构

     SSR _Nuxt_.js 是一个基于 Vue.js 的轻量级应用框架,可用来创建服务端渲染 (SSR) 应用,也可充当静态站点引擎生成静态站点应用,具有优雅的代码结构分层和热加载等特性。暂定 Nuxt.js

     组件化需要先完成 UI 组件化，需要 UI 设计一同达成，可以基于一套 UI 组件去二次封装

     非核心业务，可以使用一些其他技术栈例如 React、Uniapp

2. tips

   善用 github，很多时候搜索引擎搜不到的在 github 中能找到

   善用 awesome， 关键词+ awesome 能找到不少聚合资料
